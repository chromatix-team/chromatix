# %% helpers_sampling.py
import jax
import jax.numpy as jnp
import matplotlib as mpl
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import math


def fibonacci_sphere_sampling(num_points: int) -> jnp.ndarray:
    """
    Generate `num_points` approximately uniformly distributed points on the
    surface of the unit sphere using a Fibonacci layout.
    """
    alpha = jnp.pi * (3.0 - jnp.sqrt(5.0))  # golden angle
    i = jnp.arange(num_points)
    z = 1.0 - 2.0 * (i + 0.5) / num_points
    r = jnp.sqrt(1.0 - z**2)
    phi = alpha * i
    x = r * jnp.cos(phi)
    y = r * jnp.sin(phi)
    coords = jnp.column_stack((x, y, z))
    return coords

def fibonacci_cone_sampling(num_angles: int,
                            NA: float,
                            n: float,
                            overshoot_factor: int = 4,
                            rng: jax.random.PRNGKey = jax.random.PRNGKey(0)) -> jnp.ndarray:
    """
    Generate `num_angles` directions on the unit sphere within the cone
    defined by NA/n (Abbe sine condition).
    """
    # Generate a larger set of points on the sphere
    N_full = overshoot_factor * num_angles
    coords = fibonacci_sphere_sampling(N_full)

    # Cone filter
    z_min = jnp.sqrt(1.0 - (NA / n)**2)
    mask = coords[:, 2] >= z_min
    coords_in_cone = coords[mask]

    # If no points in cone, return the north pole
    if coords_in_cone.shape[0] == 0:
        coords_in_cone = jnp.array([[0.0, 0.0, 1.0]], dtype=jnp.float32)

    # Downsample to get exactly num_angles
    n_sub = coords_in_cone.shape[0]
    if n_sub < num_angles:
        print(f"Warning: Only {n_sub} angles found within NA cone, but {num_angles} requested. Some angles will be repeated.")
        idx = jax.random.choice(rng, n_sub, shape=(num_angles,), replace=True)
    else:
        if n_sub > num_angles:
            print(f"Found {n_sub} angles within NA cone, downsampling to {num_angles} requested angles.")
        idx = jax.random.choice(rng, n_sub, shape=(num_angles,), replace=False)
    coords_in_cone = coords_in_cone[idx]

    # Convert to (theta, phi) angles
    x, y, z = coords_in_cone[:, 0], coords_in_cone[:, 1], coords_in_cone[:, 2]
    theta = jnp.arccos(z)
    phi = jnp.arctan2(y, x)
    phi = jnp.where(phi < 0, phi + 2*jnp.pi, phi)
    angles = jnp.column_stack((theta, phi))
    return angles

def ring_at_largest_na(num_angles: int, NA: float, n: float) -> jnp.ndarray:
    """
    Generates a single ring of angles at the maximum half-angle allowed by NA.
    """
    theta_max = jnp.arcsin(NA / n)
    phi_vals = jnp.linspace(0, 2*jnp.pi, num_angles, endpoint=False)
    theta_vals = jnp.full((num_angles,), theta_max)
    angles_ring = jnp.column_stack([theta_vals, phi_vals])
    return angles_ring

def visualize_fibonacci_sphere(num_points=500):
    """
    Plot points generated by the Fibonacci sphere sampling.
    """
    points = fibonacci_sphere_sampling(num_points)
    fig = plt.figure()
    ax = fig.add_subplot(projection='3d')
    ax.scatter(points[:, 0], points[:, 1], points[:, 2], s=10)
    ax.set_aspect('equal')
    ax.set_title(f"Fibonacci Sphere (num_points={num_points})")
    plt.show()

def visualize_fibonacci_cone(num_angles=100, NA=1.0, n=1.0, overshoot_factor=2):
    """
    Plot directions in the cone using the Fibonacci-based cone sampling.
    """
    angles_in_cone = fibonacci_cone_sampling(num_angles, NA, n, overshoot_factor)
    
    # Extract angles
    theta_vals = angles_in_cone[:, 0]
    phi_vals   = angles_in_cone[:, 1]
    
    # Convert spherical -> Cartesian
    r_vals = jnp.ones_like(theta_vals)
    x_vals = r_vals * jnp.sin(theta_vals) * jnp.cos(phi_vals)
    y_vals = r_vals * jnp.sin(theta_vals) * jnp.sin(phi_vals)
    z_vals = r_vals * jnp.cos(theta_vals)

    fig = plt.figure()
    ax = fig.add_subplot(projection='3d')
    ax.scatter(x_vals, y_vals, z_vals, s=20, c='blue')
    ax.set_box_aspect((1,1,1))
    ax.set_title(f"Fibonacci Cone Sampling\n(num_angles={num_angles}, NA={NA}, n={n})")
    plt.show()

def visualize_kohler_illumination(num_angles=100, NA=1.0, n=1.0, overshoot_factor=2):
    """
    Visualize the angles used in Köhler illumination up to a certain numerical
    aperture (NA) in a medium with refractive index n.

    - num_angles: the number of distinct (theta, phi) directions to generate.
    - NA: the numerical aperture defining the maximum cone of illumination.
    - n: refractive index of the medium (often 1.0 for air).
    - overshoot_factor: how many more points to generate before filtering down
      to `num_angles`. A larger factor may help ensure a good spread.
    """
    angles_in_cone = fibonacci_cone_sampling(num_angles, NA, n, overshoot_factor)
    
    # Extract angles
    theta_vals = angles_in_cone[:, 0]
    phi_vals   = angles_in_cone[:, 1]
    
    # Convert spherical -> Cartesian for plotting
    r_vals = jnp.ones_like(theta_vals)
    x_vals = r_vals * jnp.sin(theta_vals) * jnp.cos(phi_vals)
    y_vals = r_vals * jnp.sin(theta_vals) * jnp.sin(phi_vals)
    z_vals = r_vals * jnp.cos(theta_vals)

    # Plot
    fig = plt.figure(figsize=(8, 8))
    ax = fig.add_subplot(projection='3d')
    ax.scatter(x_vals, y_vals, z_vals, s=20, c='blue')
    ax.set_box_aspect((1,1,1))
    
    ax.set_title(f"Köhler Illumination Directions\n"
                 f"(num_angles={num_angles}, NA={NA}, n={n})")
    ax.set_xlabel("X")
    ax.set_ylabel("Y")
    ax.set_zlabel("Z")

    plt.show()

def visualize_kohler_illumination_side_by_side_1(num_angles=100, NA=1.0, n=1.0, overshoot_factor=2):
    """
    Plot (side-by-side) the Köhler illumination directions in 3D and their
    projection onto a disk, representing the front focal plane of the condenser.

    - num_angles: number of directions (theta, phi) to generate.
    - NA: numerical aperture defining the max illumination cone.
    - n: refractive index of the medium (often 1.0 for air).
    - overshoot_factor: how many more points to initially sample, giving a
      better spread before filtering to `num_angles`.
    """
    # Get angles within the cone
    angles_in_cone = fibonacci_cone_sampling(num_angles, NA, n, overshoot_factor)
    
    # Convert from (theta, phi) to Cartesian for the 3D sphere
    theta_vals = angles_in_cone[:, 0]
    phi_vals   = angles_in_cone[:, 1]
    
    x_vals = jnp.sin(theta_vals) * jnp.cos(phi_vals)
    y_vals = jnp.sin(theta_vals) * jnp.sin(phi_vals)
    z_vals = jnp.cos(theta_vals)

    theta_vals_np = theta_vals.__array__()
    
    # For the disk projection (the front focal plane),
    # the radial distance r = sin(theta), so max r = NA/n
    # We'll just plot (x_proj, y_proj) = (r cos phi, r sin phi) = (x_vals, y_vals)
    # since x_vals = sin(theta)*cos(phi), etc.
    # The circle boundary is radius = NA/n.
    x_proj = x_vals
    y_proj = y_vals
    max_r  = NA/n
    theta_max = jnp.rad2deg(jnp.arcsin(NA/n))
    # Create a wide figure
    fig = plt.figure(figsize=(13, 5))
    
    # --- Left subplot: 3D sphere scatter ---
    ax3d = fig.add_subplot(1, 2, 1, projection='3d')
    # scatter3d = ax3d.scatter(x_vals, y_vals, z_vals, s=20, c='blue')
    scatter3d = ax3d.scatter(
        x_vals, y_vals, z_vals,
        c=theta_vals_np,
        cmap='magma',
        s=20
    )

    cb = plt.colorbar(scatter3d, ax=ax3d, pad=0.1)
    cb.set_label('Theta (radians)')

    ax3d.set_xlabel("$x$")
    ax3d.set_ylabel("$y$")
    ax3d.set_zlabel("$z$")
    ax3d.set_xticks([-1.0, 0.0, 1.0])
    ax3d.set_yticks([-1.0, 0.0, 1.0])
    # # ax3d.set_zticks([-1.0, 0.0, 1.0])
    ax3d.set_box_aspect((1,1,1))
    # xlim = ax3d.get_xlim3d()
    # ylim = ax3d.get_ylim3d()
    # zlim = ax3d.get_zlim3d()
    # ranges = (xlim[1]-xlim[0], ylim[1]-ylim[0], zlim[1]-zlim[0])
    # max_range = max(ranges)
    # mid_x = 0.5 * sum(xlim)
    # mid_y = 0.5 * sum(ylim)
    # mid_z = 0.5 * sum(zlim)
    # ax3d.set_xlim3d([mid_x - max_range/2, mid_x + max_range/2])
    # ax3d.set_ylim3d([mid_y - max_range/2, mid_y + max_range/2])
    # ax3d.set_zlim3d([mid_z - max_range/2, mid_z + max_range/2])
    # # Set ticks based on the ranges
    # ax3d.set_xticks([xlim[0], 0.0, xlim[1]])
    # ax3d.set_yticks([-1.0, 0.0, 1.0])
    # ax3d.set_zticks([-1.0, 0.0, 1.0])
    
    # Use actual data ranges for proper scaling instead of fixed values
    x_range = jnp.max(x_vals) - jnp.min(x_vals)
    y_range = jnp.max(y_vals) - jnp.min(y_vals)
    z_range = jnp.max(z_vals) - jnp.min(z_vals)
    # Ensure non-zero ranges to avoid division issues
    x_range = jnp.maximum(x_range, 0.001)
    y_range = jnp.maximum(y_range, 0.001)
    z_range = jnp.maximum(z_range, 0.001)
    ax3d.set_box_aspect((x_range, y_range, z_range*3))
    print(x_range, y_range, z_range)
    # ax3d.set_title(
    #     f"Köhler Illumination (3D)\n(num_angles={num_angles}, NA={NA}, n={n})",
    #     pad=15
    # )
    ax3d.set_title(
        f"3D Distribution of Illumination Angles\n(num_angles={num_angles}, NA={NA}, n={n})",
        pad=15
    )
    
    # --- Right subplot: Projection onto disk (front focal plane) ---
    ax2d = fig.add_subplot(1, 2, 2)
    # ax2d.scatter(x_proj, y_proj, s=20, c='blue')
    ax2d.scatter(x_proj, y_proj, s=20, c=theta_vals_np, cmap='magma')
   
    # Red boundary circle at radius = max_r
    circle = plt.Circle((0, 0), radius=max_r, fill=False, color='red', linewidth=2)
    ax2d.add_patch(circle)

    ax2d.set_xticks([])
    ax2d.set_yticks([])
    ax2d.set_aspect('equal', 'box')
    ax2d.set_xlim(-1.1 * max_r, 1.1 * max_r)
    ax2d.set_ylim(-1.1 * max_r, 1.1 * max_r)
    # ax2d.set_xlabel("$x$ (front focal plane)")
    # ax2d.set_ylabel("$y$ (front focal plane)")

    # Add some text: label the disk boundary, mention the max angle in degrees
    # ax2d.text(
    #     0.05, 0.95,
    #     f"Max radius = NA/n = {max_r:.2f}\nMax half-angle = {theta_max:.2f}°",
    #     transform=ax2d.transAxes,
    #     fontsize=10, color='red',
    #     verticalalignment='top'
    # )
    ax2d.annotate(
        "Max radius = NA/n = 0.80\nMax half-angle = 53.13°",
        xy=(0, max_r),  # near the top edge of the circle
        xytext=(0, 1.1 * max_r),  # slightly above
        arrowprops=dict(arrowstyle="->", color="red"),
        ha="center", color='red'
    )
    ax2d.set_title("Projection onto Condenser FFP\n(front focal plane)", pad=15)
    # ax2d.set_title("Projection onto Condenser FFP")

    plt.tight_layout()
    plt.show()

def visualize_kohler_illumination_side_by_side(num_angles=100, NA=1.0, n=1.0, overshoot_factor=2):
    """
    Plot (side-by-side) the Köhler illumination directions in 3D and their
    projection onto a disk, representing the front focal plane of the condenser.

    - num_angles: number of directions (theta, phi) to generate.
    - NA: numerical aperture defining the max illumination cone.
    - n: refractive index of the medium (often 1.0 for air).
    - overshoot_factor: how many more points to initially sample, giving a
      better spread before filtering to `num_angles`.
    """
    # 1) Generate angles within the cone
    angles_in_cone = fibonacci_cone_sampling(num_angles, NA, n, overshoot_factor)

    # 2) Convert (theta, phi) to Cartesian for the 3D sphere
    theta_vals = angles_in_cone[:, 0]
    phi_vals   = angles_in_cone[:, 1]
    
    x_vals = jnp.sin(theta_vals) * jnp.cos(phi_vals)
    y_vals = jnp.sin(theta_vals) * jnp.sin(phi_vals)
    z_vals = jnp.cos(theta_vals)
    
    # Convert to numpy arrays for Matplotlib
    x_vals_np = x_vals.__array__()
    y_vals_np = y_vals.__array__()
    z_vals_np = z_vals.__array__()
    theta_vals_np = theta_vals.__array__()

    # 3) For the disk projection (front focal plane),
    #    the radial distance is r = sin(theta), so max r = NA/n
    x_proj = x_vals_np
    y_proj = y_vals_np
    max_r  = NA / n

    # 4) Create a wide figure with 2 subplots + space on the right for colorbar
    fig = plt.figure(figsize=(13, 5))
    gs = fig.add_gridspec(nrows=1, ncols=3, width_ratios=[1,1,0.05], wspace=0.15)
    plt.suptitle("Köhler Illumination: Fibonnacci Sampling Distribution", fontsize=14, y=1.05)
    # plt.suptitle("Köhler Illumination: Angular Distribution\n" + 
    #              r"$\bf{Fibonacci}$ $\bf{Sampling}$ $\bf{on}$ $\bf{a}$ $\bf{Sphere}$", 
    #              fontsize=14, y=1.05, color=['(0,0,0)', '(30,144,255)'])
    
    ax3d = fig.add_subplot(gs[0, 0], projection='3d')
    ax2d = fig.add_subplot(gs[0, 1])
    cbar_ax = fig.add_subplot(gs[0, 2])  # for a single colorbar on the far right

    # 5) Set up a shared colormap/norm so both plots use the same color scale
    # norm = mpl.colors.Normalize(vmin=theta_vals_np.min(), vmax=theta_vals_np.max())
    # cmap = mpl.cm.get_cmap('magma')
    vmin = theta_vals_np.min()
    vmax = theta_vals_np.max()
    norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax)
    cmap = mpl.cm.magma

    # --- Left: 3D sphere scatter ---
    scatter3d = ax3d.scatter(
        x_vals_np, y_vals_np, z_vals_np,
        c=theta_vals_np, cmap=cmap, norm=norm, s=20
    )
    ax3d.set_title(f"3D Distribution of Köhler Illumination Angles", pad=15)
    # ax3d.set_title(f"Köhler Illumination (3D)\n(num_angles={num_angles}, NA={NA}, n={n})", pad=15)
    ax3d.set_xlabel("$x$")
    ax3d.set_ylabel("$y$")
    ax3d.set_zlabel("$z$")

    ax3d.set_xticks([-1.0, 0.0, 1.0])
    ax3d.set_yticks([-1.0, 0.0, 1.0])

    # Make 3D aspect ratio proportional to the data's x, y, z ranges
    x_range = x_vals_np.max() - x_vals_np.min()
    y_range = y_vals_np.max() - y_vals_np.min()
    z_range = z_vals_np.max() - z_vals_np.min()
    # Guard against zero range for small sets
    x_range = max(x_range, 1e-6)
    y_range = max(y_range, 1e-6)
    z_range = max(z_range, 1e-6)
    # ax3d.set_box_aspect((x_range, y_range, z_range))

    ax3d.set_zticks([round(z_vals_np.min(), 2), round(z_vals_np.min() + z_range / 2, 2), round(z_vals_np.max(), 2)])

    # --- Right: Projection onto disk (front focal plane) ---
    sc2d = ax2d.scatter(
        x_proj, y_proj, c=theta_vals_np, cmap=cmap, norm=norm, s=20
    )
    # ax2d.set_title("Illumination Angles Projected into\nthe Condenser's Front Focal Plane", pad=15)
    ax2d.set_title("Projected into Condenser's Front Focal Plane", pad=15)

    circle = plt.Circle((0, 0), radius=max_r, fill=False, color='dodgerblue', linewidth=2)
    ax2d.add_patch(circle)

    ax2d.spines["top"].set_visible(False)
    ax2d.spines["right"].set_visible(False)
    ax2d.set_xlabel("$x$")
    ax2d.set_ylabel("$y$")
    ax2d.set_aspect('equal', 'box')
    ax2d.set_xlim(-1.1 * max_r, 1.1 * max_r)
    ax2d.set_ylim(-1.1 * max_r, 1.1 * max_r)
    ax2d.set_xticks([])
    ax2d.set_yticks([])

    theta_max_deg = math.degrees(math.asin(NA / n))
    ax2d.text(
        -0.55, 0.98,
        f"Max radius = NA/n = {max_r:.2f}\nMax half-angle = {theta_max_deg:.2f}°",
        transform=ax2d.transAxes, fontsize=10, color='dodgerblue',
        verticalalignment='top'
    )

    sm = mpl.cm.ScalarMappable(norm=norm, cmap=cmap)
    sm.set_array([])
    cb = plt.colorbar(sm, cax=cbar_ax)
    cb.set_label('Theta (radians)')

    plt.tight_layout()
    plt.show()

    return fig

def generate_kohler_2d_points(num_angles: int, NA: float, n: float, overshoot_factor: int = 10, 
                              rng: jax.random.PRNGKey = jax.random.PRNGKey(0)) -> jnp.ndarray:
    """
    Generate 2D points representing the projection of Köhler illumination angles 
    onto the front focal plane of the condenser.
    
    Parameters:
    -----------
    num_angles : int
        Number of illumination angles to generate
    NA : float
        Numerical aperture defining the maximum cone of illumination
    n : float
        Refractive index of the medium
    overshoot_factor : int, optional
        How many more points to initially sample before filtering, by default 4
    rng : jax.random.PRNGKey, optional
        Random number generator key, by default jax.random.PRNGKey(0)
        
    Returns:
    --------
    jnp.ndarray
        Array of shape (num_angles, 2) containing the (x, y) coordinates of the 
        2D projections. These points lie within a disk of radius NA/n.
    """
    # Generate angles within the cone
    angles_in_cone = fibonacci_cone_sampling(num_angles, NA, n, overshoot_factor, rng)

    # angles_in_cone = ring_at_largest_na(num_angles, NA, n)
    
    # Convert (theta, phi) to (x, y) projections
    theta_vals = angles_in_cone[:, 0]
    phi_vals = angles_in_cone[:, 1]
    
    # The projection is simply (sin(theta)*cos(phi), sin(theta)*sin(phi))
    x_proj = jnp.sin(theta_vals) * jnp.cos(phi_vals)
    y_proj = jnp.sin(theta_vals) * jnp.sin(phi_vals)
    
    # Stack into a single array of (x, y) coordinates
    points_2d = jnp.column_stack((x_proj, y_proj))
    
    return points_2d

def test_kohler_2d_points():
    # Example parameters
    NA = 1.4
    n = 1.5
    num_angles = 1000
    
    rng = jax.random.PRNGKey(0)
    points_2d = generate_kohler_2d_points(num_angles, NA, n, rng=rng)
    
    # Compute radius of each point from origin
    radii = jnp.sqrt(jnp.sum(points_2d**2, axis=1))
    
    # Check maximum radius
    max_radius = jnp.max(radii)
    allowed_radius = NA / n
    print(f"Max radius = {max_radius:.6f}")
    print(f"Allowed disk radius = {allowed_radius:.6f}")
    
    # Print min and max values among all coordinates of the points
    min_val = jnp.min(points_2d)
    max_val = jnp.max(points_2d)
    print(f"Minimum coordinate value = {min_val:.6f}")
    print(f"Maximum coordinate value = {max_val:.6f}")
    
    # Assertion to ensure all points lie within the allowed disk
    assert max_radius <= allowed_radius + 1e-7, \
        f"Points exceed the disk radius (max {max_radius:.6f} vs. allowed {allowed_radius:.6f})."
    print("All points lie within the disk of radius NA/n.")


# %%
if __name__ == "__main__":
    fig = visualize_kohler_illumination_side_by_side(num_angles=400, NA=0.8, n=1.0, overshoot_factor=5)
    fig.savefig("kohler_illumination_distribution.png", dpi=300, transparent=True, bbox_inches='tight')
# %%
